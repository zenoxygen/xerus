[1mdiff --git a/src/client.rs b/src/client.rs[m
[1mindex 96e4040..5520dfe 100644[m
[1m--- a/src/client.rs[m
[1m+++ b/src/client.rs[m
[36m@@ -210,7 +210,7 @@[m [mimpl Client {[m
         }[m
 [m
         // Read message[m
[31m-        let mut message_buf: Vec<u8> = vec![0; message_len as usize];[m
[32m+[m[32m        let mut message_buf: Vec<u8> = vec![0; message_len];[m
         if self.conn.read_exact(&mut message_buf).is_err() {[m
             return Err(anyhow!("could not read message received from peer"));[m
         }[m
[36m@@ -224,7 +224,7 @@[m [mimpl Client {[m
     /// Read message length.[m
     fn read_message_len(&mut self) -> Result<usize> {[m
         // Read bytes into buffer[m
[31m-        let mut buf = [0; 4];[m
[32m+[m[32m        let mut buf = vec![0; 4];[m
         if self.conn.read_exact(&mut buf).is_err() {[m
             return Err(anyhow!("could not read message length received from peer"));[m
         }[m
[1mdiff --git a/src/handshake.rs b/src/handshake.rs[m
[1mindex 9a1b34b..3216824 100644[m
[1m--- a/src/handshake.rs[m
[1m+++ b/src/handshake.rs[m
[36m@@ -100,29 +100,14 @@[m [mimpl Handshake {[m
 /// * `pstrlen` - Length of protocol identifier.[m
 ///[m
 pub fn deserialize_handshake(handshake_buf: &Vec<u8>, pstrlen: usize) -> Result<Handshake> {[m
[31m-    let mut pstr = vec![];[m
[31m-    let mut reserved = vec![0; 8];[m
[31m-    let mut info_hash = vec![];[m
[31m-    let mut peer_id = vec![];[m
[31m-[m
[31m-    for (i, x) in handshake_buf.iter().enumerate() {[m
[31m-        // Get pstr[m
[31m-        if i < pstrlen {[m
[31m-            pstr.push(x.to_owned());[m
[31m-        }[m
[31m-        // Get reserved[m
[31m-        if i >= pstrlen && i < pstrlen + 8 {[m
[31m-            reserved.push(x.to_owned());[m
[31m-        }[m
[31m-        // Get info hash[m
[31m-        if i >= pstrlen + 8 && i < pstrlen + 8 + 20 {[m
[31m-            info_hash.push(x.to_owned());[m
[31m-        }[m
[31m-        // Get peer id[m
[31m-        if i >= pstrlen + 8 + 20 {[m
[31m-            peer_id.push(x.to_owned());[m
[31m-        }[m
[31m-    }[m
[32m+[m[32m    // Get pstr[m
[32m+[m[32m    let pstr = handshake_buf[0..pstrlen].to_vec();[m
[32m+[m[32m    // Get reserved[m
[32m+[m[32m    let reserved = handshake_buf[pstrlen..(pstrlen + 8)].to_vec();[m
[32m+[m[32m    // Get info hash[m
[32m+[m[32m    let info_hash = handshake_buf[(pstrlen + 8)..(pstrlen + 8 + 20)].to_vec();[m
[32m+[m[32m    // Get peer id[m
[32m+[m[32m    let peer_id = handshake_buf[(pstrlen + 8 + 20)..].to_vec();[m
 [m
     // Build handshake[m
     let handshake = Handshake {[m
[1mdiff --git a/src/message.rs b/src/message.rs[m
[1mindex e54e09a..6402629 100644[m
[1m--- a/src/message.rs[m
[1m+++ b/src/message.rs[m
[36m@@ -84,12 +84,10 @@[m [mimpl Message {[m
         let message_len = 1 + self.payload.len();[m
 [m
         // Create a new buffer[m
[31m-        let mut serialized: Vec<u8> = vec![0; 4 + message_len];[m
[32m+[m[32m        let mut serialized: Vec<u8> = vec![];[m
 [m
         // Add message length[m
[31m-        let mut len: Vec<u8> = vec![];[m
[31m-        len.write_u32::<BigEndian>(message_len as u32)?;[m
[31m-        serialized.append(&mut len);[m
[32m+[m[32m        serialized.write_u32::<BigEndian>(message_len as u32)?;[m
 [m
         // Add message id[m
         serialized.push(self.id);[m
[36m@@ -114,15 +112,10 @@[m [mpub fn deserialize_message(message_buf: &Vec<u8>, message_len: usize) -> Result<[m
     let id: MessageId = message_buf[0];[m
 [m
     // Get message payload[m
[31m-    let mut payload: MessagePayload = vec![];[m
[31m-    for (i, x) in message_buf.iter().enumerate() {[m
[31m-        if i > 0 && i < message_len {[m
[31m-            payload.push(x.to_owned());[m
[31m-        }[m
[31m-    }[m
[32m+[m[32m    let payload: MessagePayload = message_buf[1..message_len].to_vec();[m
 [m
     // Build message[m
[31m-    let message = Message::new_with_payload(id, payload);[m
[32m+[m[32m    let message: Message = Message::new_with_payload(id, payload);[m
 [m
     Ok(message)[m
 }[m
